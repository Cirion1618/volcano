<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Volcano Hybrid Test Control v0.24</title>
  <style>
    #log {
      max-height: 200px;
      overflow-y: auto;
      background: #f0f0f0;
      padding: 1em;
      font-family: monospace;
    }
  </style>
</head>
<body>
  <h2>Volcano Hybrid - Advanced Control Panel (v0.24)</h2>
  <button onclick="connect()">üîó Connect to Volcano</button>
  <button onclick="runWorkflowX()">üöÄ Start Custom Workflow X</button>
  <button onclick="abortWorkflow()">‚õî Abort Workflow</button>
  <p id="status">Status: Not connected</p>
  <p>Current Temperature: <span id="currentTemp">-</span>¬∞C</p>
  <p>Heater Status: <span id="heaterStatus">Unknown</span></p>
  <p>Pump Status: <span id="pumpStatus">Unknown</span></p>
  <p>Firmware Version: <span id="firmwareVersion">-</span></p>
  <div id="log"></div>

  <script>
    let server, service;
    let abortFlag = false;
    const serviceUUID = '10110000-5354-4f52-5a26-4249434b454c';
    const pumpOnUUID = '10110013-5354-4f52-5a26-4249434b454c';
    const pumpOffUUID = '10110014-5354-4f52-5a26-4249434b454c';

    const workflowX_temperature = [175, 180, 185, 190, 195];
    const workflowX_holdTimeInMilliSeconds = [7000, 7000, 0, 0, 0];
    const workflowX_pumpTimeInMilliSeconds = [7000, 7000, 7000, 7000, 10000];

    function log(msg) {
      const el = document.getElementById("log");
      el.innerText += msg + "\n";
      el.scrollTop = el.scrollHeight;
    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function wait(ms) {
      const interval = 100;
      const steps = Math.floor(ms / interval);
      for (let i = 0; i < steps; i++) {
        if (abortFlag) throw new Error("Aborted");
        await new Promise(res => setTimeout(res, interval));
      }
    }

    async function connect() {
      try {
        const device = await navigator.bluetooth.requestDevice({
          filters: [{ namePrefix: 'Volcano' }],
          optionalServices: [serviceUUID, '10100000-5354-4f52-5a26-4249434b454c']
        });

        document.getElementById("status").innerText = `Status: Connecting to ${device.name}...`;

        server = await device.gatt.connect();
        service = await server.getPrimaryService(serviceUUID);

        document.getElementById("status").innerText = `Status: Connected to ${device.name}`;
        log("Connected to device: " + device.name);

        await readFirmwareVersion();
        setInterval(updateStatuses, 3000);

      } catch (err) {
        document.getElementById("status").innerText = `Connection failed: ${err.message}`;
        log("Connection error: " + err);
      }
    }

    async function readFirmwareVersion() {
      try {
        const fwService = await server.getPrimaryService('10100000-5354-4f52-5a26-4249434b454c');
        const fwChar = await fwService.getCharacteristic('10100003-5354-4f52-5a26-4249434b454c');
        const value = await fwChar.readValue();
        const decoder = new TextDecoder("utf-8");
        const fw = decoder.decode(value);
        document.getElementById("firmwareVersion").innerText = fw.substring(0, 8);
        log("üÜï Firmware Version: " + fw);
      } catch (e) {
        log("‚ö†Ô∏è Error reading firmware version: " + e);
      }
    }

    async function runWorkflowX() {
      abortFlag = false;
      log("========= START WORKFLOW v0.24 =========");

      try {
        await stopPump();
        await sleep(300);
        await stopHeater();
        await sleep(300);

        for (let i = 0; i < workflowX_temperature.length; i++) {
          if (abortFlag) throw new Error("Aborted");

          const targetTemp = workflowX_temperature[i] * 10;
          const holdTime = workflowX_holdTimeInMilliSeconds[i];
          const pumpTime = workflowX_pumpTimeInMilliSeconds[i];

          log(`üß≠ STEP ${i + 1}: Target ${targetTemp / 10}¬∞C, Hold ${holdTime}ms, Pump ${pumpTime}ms`);

          await stopPump();
          await sleep(300);

          await setTemperature(targetTemp);
          await wait(2000);
          if (abortFlag) throw new Error("Aborted");

          await startHeater();
          await wait(500);

          await waitForTemp(targetTemp);
          if (abortFlag) throw new Error("Aborted");

          log(`‚è≥ Holding for ${holdTime}ms`);
          await wait(holdTime);

          if (pumpTime > 0) {
            log(`üí® Pumping for ${pumpTime}ms`);
            await startPumpOnly();
            await wait(pumpTime);
            await stopPump();
          } else {
            log("Skipping pump phase");
          }

          await wait(500);
        }

        await stopPump();
        await stopHeater();
        log("‚úÖ Workflow completed.");
      } catch (e) {
        if (e.message === "Aborted") {
          log("‚ùå Workflow aborted.");
          await stopPump();
          await stopHeater();
        } else {
          log("‚ö†Ô∏è Error during workflow: " + e);
        }
      }
    }

    function abortWorkflow() {
      log("‚ùå Abort requested.");
      abortFlag = true;
    }

    async function setTemperature(tempInTenthDegrees) {
      const char = await service.getCharacteristic('10110003-5354-4f52-5a26-4249434b454c');
      const buffer = new ArrayBuffer(2);
      new DataView(buffer).setUint16(0, tempInTenthDegrees, true);
      await char.writeValue(buffer);
      log(`üå°Ô∏è Set temperature to ${tempInTenthDegrees / 10}¬∞C`);
    }

    async function startHeater() {
      const char = await service.getCharacteristic('1011000f-5354-4f52-5a26-4249434b454c');
      await char.writeValue(new Uint8Array([0x01]));
      log("üî• Heater ON");
    }

    async function stopHeater() {
      const char = await service.getCharacteristic('10110010-5354-4f52-5a26-4249434b454c');
      await char.writeValue(new Uint8Array([0x01]));
      log("üõë Heater OFF");
    }

    async function waitForTemp(targetTemp) {
      const char = await service.getCharacteristic('10110001-5354-4f52-5a26-4249434b454c');
      let temp = 0;
      while (Math.abs(temp - targetTemp) > 10) {
        if (abortFlag) throw new Error("Aborted");
        const value = await char.readValue();
        temp = new DataView(value.buffer).getUint16(0, true);
        document.getElementById("currentTemp").innerText = (temp / 10).toFixed(1);
        log(`Current temp: ${temp / 10}¬∞C`);
        await wait(1500);
      }
      log("‚úÖ Target temperature reached");
    }

    async function startPumpOnly() {
      const char = await service.getCharacteristic(pumpOnUUID);
      await char.writeValue(new Uint8Array([0x01]));
      document.getElementById("pumpStatus").innerText = "ON";
      log("üí® Pump ON");
    }

    async function stopPump() {
      const char = await service.getCharacteristic(pumpOffUUID);
      await char.writeValue(new Uint8Array([0x00]));
      document.getElementById("pumpStatus").innerText = "OFF";
      log("üõë Pump OFF");
    }

    async function updateStatuses() {
      try {
        const tempChar = await service.getCharacteristic('10110001-5354-4f52-5a26-4249434b454c');
        const tempVal = await tempChar.readValue();
        const temp = new DataView(tempVal.buffer).getUint16(0, true);
        document.getElementById("currentTemp").innerText = (temp / 10).toFixed(1);

        const prj2Char = await server.getPrimaryService('10100000-5354-4f52-5a26-4249434b454c')
          .then(svc => svc.getCharacteristic('1010000d-5354-4f52-5a26-4249434b454c'));
        const prj2Val = await prj2Char.readValue();
        const prj2 = new DataView(prj2Val.buffer).getUint16(0, true);
        const heaterOn = (prj2 & 0x0004) === 0;
        document.getElementById("heaterStatus").innerText = heaterOn ? "ON" : "OFF";
      } catch (err) {
        log("‚ö†Ô∏è Error updating statuses: " + err);
      }
    }
  </script>
</body>
</html>
